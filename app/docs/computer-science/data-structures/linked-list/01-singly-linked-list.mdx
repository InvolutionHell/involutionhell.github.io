---
title: "Singly Linked List"
description: "Implementation, operations, and applications of singly linked lists"
date: "2024-01-07"
tags:
  - singly-linked-list
  - pointer-operations
  - basic-data-structure
---

# Singly Linked List

A singly linked list is the most basic form of linked list, where each node contains data and a pointer to the next node. It provides dynamic memory allocation and efficient insertion and deletion operations.

## Node Structure

```javascript
class ListNode {
    constructor(data) {
        this.data = data;    // Data field
        this.next = null;    // Pointer field, points to next node
    }
}
```

## Complete Implementation

```javascript
class SinglyLinkedList {
    constructor() {
        this.head = null;    // Head pointer
        this.size = 0;       // List length
    }

    // Insert node at head
    prepend(data) {
        const newNode = new ListNode(data);
        newNode.next = this.head;
        this.head = newNode;
        this.size++;
    }

    // Insert node at tail
    append(data) {
        const newNode = new ListNode(data);

        // If list is empty, new node becomes head node
        if (!this.head) {
            this.head = newNode;
            this.size++;
            return;
        }
        
        // Find the last node
        let current = this.head;
        while (current.next) {
            current = current.next;
        }

        // Link the new node
        current.next = newNode;
        this.size++;
    }
    
    // Insert node at specified position
    insert(index, data) {
        if (index < 0 || index > this.size) {
            throw new Error("Index out of bounds");
        }

        // Insert at head
        if (index === 0) {
            this.prepend(data);
            return;
        }

        const newNode = new ListNode(data);
        let current = this.head;

        // Find the node before the insertion position
        for (let i = 0; i < index - 1; i++) {
            current = current.next;
        }

        // Insert new node
        newNode.next = current.next;
        current.next = newNode;
        this.size++;
    }
    
    // Remove head node
    removeFirst() {
        if (!this.head) {
            return null;
        }

        const removedData = this.head.data;
        this.head = this.head.next;
        this.size--;
        return removedData;
    }

    // Remove tail node
    removeLast() {
        if (!this.head) {
            return null;
        }

        // Only one node
        if (!this.head.next) {
            const removedData = this.head.data;
            this.head = null;
            this.size--;
            return removedData;
        }

        // Find the second-to-last node
        let current = this.head;
        while (current.next.next) {
            current = current.next;
        }

        const removedData = current.next.data;
        current.next = null;
        this.size--;
        return removedData;
    }
    
    // Remove node at specified position
    remove(index) {
        if (index < 0 || index >= this.size) {
            throw new Error("Index out of bounds");
        }

        // Remove head node
        if (index === 0) {
            return this.removeFirst();
        }

        let current = this.head;

        // Find the node before the one to be removed
        for (let i = 0; i < index - 1; i++) {
            current = current.next;
        }

        const removedData = current.next.data;
        current.next = current.next.next;
        this.size--;
        return removedData;
    }
    
    // 删除指定值的第一个节点
    removeByValue(data) {
        if (!this.head) {
            return false;
        }
        
        // 如果头节点就是要删除的节点
        if (this.head.data === data) {
            this.head = this.head.next;
            this.size--;
            return true;
        }
        
        let current = this.head;
        while (current.next && current.next.data !== data) {
            current = current.next;
        }
        
        // 找到了要删除的节点
        if (current.next) {
            current.next = current.next.next;
            this.size--;
            return true;
        }
        
        return false; // 未找到
    }
    
    // 查找元素
    indexOf(data) {
        let current = this.head;
        let index = 0;
        
        while (current) {
            if (current.data === data) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1; // 未找到
    }
    
    // 获取指定位置的元素
    get(index) {
        if (index < 0 || index >= this.size) {
            throw new Error("Index out of bounds");
        }
        
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        
        return current.data;
    }
    
    // 检查链表是否包含指定元素
    contains(data) {
        return this.indexOf(data) !== -1;
    }
    
    // 获取链表长度
    length() {
        return this.size;
    }
    
    // 检查链表是否为空
    isEmpty() {
        return this.size === 0;
    }
    
    // 清空链表
    clear() {
        this.head = null;
        this.size = 0;
    }
    
    // 转换为数组
    toArray() {
        const result = [];
        let current = this.head;
        
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        
        return result;
    }
    
    // 遍历链表
    forEach(callback) {
        let current = this.head;
        let index = 0;
        
        while (current) {
            callback(current.data, index);
            current = current.next;
            index++;
        }
    }
    
    // 反转链表
    reverse() {
        let prev = null;
        let current = this.head;
        let next = null;
        
        while (current) {
            next = current.next;  // 保存下一个节点
            current.next = prev;  // 反转指针
            prev = current;       // 移动 prev
            current = next;       // 移动 current
        }
        
        this.head = prev;
    }
    
    // 打印链表
    toString() {
        if (!this.head) {
            return "Empty list";
        }
        
        const elements = [];
        let current = this.head;
        
        while (current) {
            elements.push(current.data);
            current = current.next;
        }
        
        return elements.join(" -> ");
    }
}
```

## 使用示例

```javascript
// 创建链表
const list = new SinglyLinkedList();

// 添加元素
list.append(1);
list.append(2);
list.append(3);
list.prepend(0);
console.log(list.toString()); // "0 -> 1 -> 2 -> 3"

// 插入元素
list.insert(2, 1.5);
console.log(list.toString()); // "0 -> 1 -> 1.5 -> 2 -> 3"

// 查找元素
console.log(list.indexOf(2));    // 3
console.log(list.get(1));        // 1
console.log(list.contains(3));   // true

// 删除元素
list.remove(0);                  // 删除索引 0 的元素
list.removeByValue(1.5);         // 删除值为 1.5 的元素
console.log(list.toString());    // "1 -> 2 -> 3"

// 反转链表
list.reverse();
console.log(list.toString());    // "3 -> 2 -> 1"

// 遍历链表
list.forEach((data, index) => {
    console.log(`Index ${index}: ${data}`);
});
```

## Key Algorithm Details

### 1. Pointer Changes in Insert Operation

```
Before insertion: A -> B -> C
Insert X between A and B:

Step 1: newNode.next = A.next
        A -> B -> C
        X ----↗

Step 2: A.next = newNode
        A -> X -> B -> C
```

### 2. Pointer Changes in Delete Operation

```
Before deletion: A -> B -> C -> D
Delete B:

Step 1: Find B's predecessor node A
Step 2: A.next = B.next
        A -----> C -> D
        (B is skipped, waiting for garbage collection)
```

### 3. Reverse Algorithm Details

```javascript
// Reverse process illustration
// Initial: 1 -> 2 -> 3 -> null
// Target: null <- 1 <- 2 <- 3

function reverse(head) {
    let prev = null;
    let current = head;
    
    while (current !== null) {
        let next = current.next;    // Save next node
        current.next = prev;        // Reverse current node's pointer
        prev = current;             // prev moves forward
        current = next;             // current moves forward
    }
    
    return prev; // prev now points to the new head node
}
```

## Common Interview Questions

### 1. 检测链表中的环

```javascript
function hasCycle(head) {
    if (!head || !head.next) return false;
    
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow === fast) {
            return true; // 发现环
        }
    }
    
    return false;
}
```

### 2. 找到链表的中点

```javascript
function findMiddle(head) {
    if (!head) return null;
    
    let slow = head;
    let fast = head;
    
    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}
```

### 3. 合并两个有序链表

```javascript
function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.data <= l2.data) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    // 连接剩余的节点
    current.next = l1 || l2;
    
    return dummy.next;
}
```

## Performance Optimization Tips

### 1. Tail Pointer Optimization

```javascript
class OptimizedSinglyLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;  // 维护尾指针
        this.size = 0;
    }
    
    append(data) {
        const newNode = new ListNode(data);
        
        if (!this.head) {
            this.head = this.tail = newNode;
        } else {
            this.tail.next = newNode;
            this.tail = newNode;
        }
        
        this.size++;
    }
    
    // 现在 append 操作是 O(1) 而不是 O(n)
}
```

### 2. Sentinel Node Optimization

```javascript
class SentinelLinkedList {
    constructor() {
        this.sentinel = new ListNode(null); // Sentinel node
        this.sentinel.next = null;
        this.size = 0;
    }
    
    // With sentinel node, many operation edge case handling becomes simpler
    prepend(data) {
        const newNode = new ListNode(data);
        newNode.next = this.sentinel.next;
        this.sentinel.next = newNode;
        this.size++;
    }
}
```

## Practical Application Scenarios

### 1. Implement Stack

```javascript
class Stack {
    constructor() {
        this.list = new SinglyLinkedList();
    }
    
    push(item) {
        this.list.prepend(item);
    }
    
    pop() {
        return this.list.removeFirst();
    }
    
    peek() {
        return this.list.isEmpty() ? null : this.list.get(0);
    }
    
    isEmpty() {
        return this.list.isEmpty();
    }
}
```

### 2. Implement Queue

```javascript
class Queue {
    constructor() {
        this.head = null;
        this.tail = null;
    }
    
    enqueue(item) {
        const newNode = new ListNode(item);
        if (!this.tail) {
            this.head = this.tail = newNode;
        } else {
            this.tail.next = newNode;
            this.tail = newNode;
        }
    }
    
    dequeue() {
        if (!this.head) return null;
        
        const item = this.head.data;
        this.head = this.head.next;
        if (!this.head) this.tail = null;
        
        return item;
    }
}
```

## Important Notes

1. **Null Pointer Checks**: Always check if nodes are null
2. **Edge Cases**: Pay special attention to empty lists and single-node situations
3. **Memory Management**: In languages with manual memory management, remember to free deleted nodes
4. **Pointer Operation Order**: Pay attention to the order of pointer modifications during insertion and deletion

## Summary

Singly linked lists are the foundation for understanding linked list data structures. Although they are not as efficient as arrays for random access, they excel in dynamic insertion and deletion operations. Mastering the implementation and operations of singly linked lists is essential for learning more complex data structures.

In the next section, we will learn about doubly linked lists and see how they provide more flexibility by adding reverse pointers.
